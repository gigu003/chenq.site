{
  "hash": "f13d36dae92328a5a374fa32cd3f6522",
  "result": {
    "markdown": "---\ntitle: 利用ggplot2制作金字塔图，展示人口结构数据\ndate: '2022-02-21'\nslug: ggplot2\nlink: https://chenq.site/tech/2022-ggplot2/\ncategories: [R,科研作图]\nkeywords: [R,科研作图,ggplot2]\nsummary: '人口金字塔图是描述一个地区或国家人口结构类型的常用图示方式，今天我们介绍一下如何利用R语言制作金字塔图，快来看看如何作金字塔图吧！'\n---\n\n\n\n## 什么是人口金字塔图？\n\n人口金字塔是用类似古埃及金字塔的形象描绘人口年龄和性别分布状况的图形。能表明人口现状及其发展类型，比如看一个地区或国家的人口结构类型是扩展型、稳定型或者收缩型。    \n\n图形的画法是：按男女人口年龄自然顺序自下而上在纵轴左右画成并列的横条柱，各条柱代表各个年龄组。底端标有按一定计算单位或百分比表示的人口数量。\n\n下面我们介绍一下如何利用R画出人口金字塔图。\n\n## 用到哪些R包？\n\n今天主要用到 dplyr包、reshape2包、ggplot2包和cowplot包。 dplyr包和reshape2包用来进行数据整理，ggplot2包和cowplot包用来画图和整合。\n\n\n\n## 加载这些R包\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_2919c4d0bfffd4177eb09a7ddb6496f6'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(cowplot)\n```\n:::\n\n\n## 数据处理\n\n首先需要把我们手里的现有数据读取到R工作环境，然后把数据调整为ggplot2包绘图所需要的格式。\n\n我们看一下，我们目前的数据结构和变量基本信息吧，目前我们有一个数据框，数据框里有20列数据，第一列为性别(sex),其余分别为0~，1~，4~，...，85+岁组各年龄组的人口数据。 \n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_2cecb5de7c9d681e2516d41e57b65258'}\n\n```{.r .cell-code}\npop  <- read.csv(\"pop.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in read.table(file = file, header = header, sep = sep, quote = quote, :\nincomplete final line found by readTableHeader on 'pop.csv'\n```\n:::\n\n```{.r .cell-code}\npop <- pop %>%\n  #把合计人口数去掉只保留男性和女性人口\n  filter(sex %in% c(\"男性\",\"女性\"))\nhead(pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   sex     r0     r1      r5     r10     r15     r20     r25     r30     r35\n1 男性 193565 924420 1186130 1158427 1130776 1254271 1426065 1291455 1279639\n2 女性 176068 821772 1038768  991518 1002524 1162174 1365563 1235362 1208151\n      r40     r45     r50    r55    r60    r65    r70    r75    r80    r85\n1 1322747 1338809 1145094 941395 812746 622679 440440 300147 183825 102596\n2 1261624 1292094 1101333 918208 801106 635924 467743 342476 228937 164663\n```\n:::\n:::\n\n\n但是，ggplot2绘图需要读取纵向格式的数据，也就是说我们需要把目前的数据格式转换成两列，一列为性别，另一列为人口数。因此，我们需要把目前的数据转换成纵向结构数据。\n\nreshape2包的melt函数可以把横向数据转换为纵向数据，id.vars参数指定保留的变量名称，其余的变量都转职置为纵向结构，转换为两列，一列存放变量名，一列存放变量值。variable.name指定存放变量名的那一列的变量名，value.name指定存放变量值的那一列的变量名。\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_3ee3674e58e1550dcaffa840c1c6640f'}\n\n```{.r .cell-code}\n# 对横向数据进行转置，然后存入pop数据框\npop <- pop %>%\n# reshape2包的melt函数转置横向数据\n  melt(id.vars=c(\"sex\"),\n       variable.name=\"age\",\n       value.name = \"pop\")\n```\n:::\n\n现在来看看转置后的数据吧\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_01230694d53edce0d1719cb9750c3069'}\n\n```{.r .cell-code}\nhead(pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   sex age     pop\n1 男性  r0  193565\n2 女性  r0  176068\n3 男性  r1  924420\n4 女性  r1  821772\n5 男性  r5 1186130\n6 女性  r5 1038768\n```\n:::\n:::\n\n然后把目前pop数据框的age变量值进行转换，因为它的值就是人口金字塔中显示的年龄组的值。\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_668824e9a6a238105d3ab5b362c3acd1'}\n\n```{.r .cell-code}\npop<-pop%>%\n  mutate(age=as.numeric(gsub(\"r\",\"\",age)),\n         pop=ifelse(sex==\"男性\",-pop,pop))\n```\n:::\n\n\n绘制人口金字塔的时候，横条的长度采用跟年龄组人口数占相应人口的百分比来表示，因此计算人口百分比数据。 \n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_62fa430b3e19785ea9b6b03fd5ea65e6'}\n\n```{.r .cell-code}\nage_label<- c(\"0\",\"1-4\",\"5-9\",\"10-14\",\"15-19\",\"20-24\",\"25-29\",\"30-34\",\"35-39\",\"40-44\",\"45-49\",\"50-54\",\"55-59\",\"60-64\",\"65-69\",\"70-74\",\"75-79\",\"80-84\",\"85-\")\npop <- pop%>%\n  group_by(sex)%>%\n  mutate(pop_rate=pop/sum(pop)*100)%>%\n  mutate(pop_rate=ifelse(sex==\"男性\",-pop_rate,pop_rate))\n```\n:::\n\n\n然后把人口数据拆分成男性和女性两个数据框，并把这个两个数据框存入列表ct\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_9835224b9fc3aed6aa0141c1e14da11b'}\n\n```{.r .cell-code}\nct <- pop%>%group_by(sex)%>%group_split()\nct\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<list_of<\n  tbl_df<\n    sex     : character\n    age     : double\n    pop     : integer\n    pop_rate: double\n  >\n>[2]>\n[[1]]\n# A tibble: 19 × 4\n   sex     age     pop pop_rate\n   <chr> <dbl>   <int>    <dbl>\n 1 女性      0  176068     1.09\n 2 女性      1  821772     5.07\n 3 女性      5 1038768     6.41\n 4 女性     10  991518     6.11\n 5 女性     15 1002524     6.18\n 6 女性     20 1162174     7.17\n 7 女性     25 1365563     8.42\n 8 女性     30 1235362     7.62\n 9 女性     35 1208151     7.45\n10 女性     40 1261624     7.78\n11 女性     45 1292094     7.97\n12 女性     50 1101333     6.79\n13 女性     55  918208     5.66\n14 女性     60  801106     4.94\n15 女性     65  635924     3.92\n16 女性     70  467743     2.88\n17 女性     75  342476     2.11\n18 女性     80  228937     1.41\n19 女性     85  164663     1.02\n\n[[2]]\n# A tibble: 19 × 4\n   sex     age      pop pop_rate\n   <chr> <dbl>    <int>    <dbl>\n 1 男性      0  -193565   -1.13 \n 2 男性      1  -924420   -5.42 \n 3 男性      5 -1186130   -6.95 \n 4 男性     10 -1158427   -6.79 \n 5 男性     15 -1130776   -6.63 \n 6 男性     20 -1254271   -7.35 \n 7 男性     25 -1426065   -8.36 \n 8 男性     30 -1291455   -7.57 \n 9 男性     35 -1279639   -7.50 \n10 男性     40 -1322747   -7.76 \n11 男性     45 -1338809   -7.85 \n12 男性     50 -1145094   -6.71 \n13 男性     55  -941395   -5.52 \n14 男性     60  -812746   -4.77 \n15 男性     65  -622679   -3.65 \n16 男性     70  -440440   -2.58 \n17 男性     75  -300147   -1.76 \n18 男性     80  -183825   -1.08 \n19 男性     85  -102596   -0.602\n```\n:::\n:::\n\n\n为了使用方便，我们编制一个函数，并利用lapply函数把ct列表放入进去，这样就可以自动生成横向条形图。\n\n## 制作金字塔图的思路\n\n我们先编写一个函数，实现对列表数据进行处理，判断如果是男性数据的话则生成左侧横向条形图，如果是女性数据的话则生成右侧横向条形图，然后把利用cowplot把左侧条形图和右侧条形图组成一个金字塔图。\n\n上程序：\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_83fdc5f51f0bfdffec602bb205c25be1'}\n\n```{.r .cell-code}\n# top_value <-  max(abs(pop$pop_rate)) \np<- lapply(ct,function(x) {\n  sexx <- x[1,c(\"sex\")]\n  abslabel <- function(x) {paste(abs(x),\"%\",sep=\"\")}\n  mycolor <- ifelse(sexx==\"男性\",paste(\"steelblue\"),paste(\"red\"))\n  pp<-ggplot(x) + \n    geom_bar(aes(x=pop_rate,y=factor(age,labels=age_label)), stat = \"identity\",color=\"white\",width=0.9,fill=ifelse(x$pop_rate>0,'#e31a1c','#1f78b4'))+\n    scale_x_continuous(expand = expansion(),limits=c(0,9.9),labels=abslabel)+\n    xlab(ifelse(sexx==\"男性\",\"男性\",\"女性\"))+\n    theme_void()+\n    theme(\n      axis.title.y = element_blank(),\n      panel.border = element_blank(),\n      panel.grid=element_blank(),\n      panel.grid.major =element_blank(),\n      axis.ticks.y = element_blank(),\n      axis.line.y=element_blank(),\n      axis.text.x = element_text(face=\"bold\"),\n      axis.text.y =element_text(size=12),\n      axis.title.x=element_text(size=12)\n    )\n  if (sexx==\"男性\"){ pp<- pp+ theme(axis.text.y =element_blank())+scale_x_continuous(expand = expansion(),limits=c(-9.9,0),labels=abslabel)\n  }\n  return(pp)\n})\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for x is already present.\nAdding another scale for x, which will replace the existing scale.\n```\n:::\n:::\n\n\n上面的程序有已经把生成的左侧和右侧条形图放入列表p，下面把列表的第一个元素和第二个元素利用cowplot组合起来就是一个金字塔图了。\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_9a7f81c0d506cd7011bd49c7b3d71b3a'}\n\n```{.r .cell-code}\n# 利用plot_grid来组合p列表元素，进行横向拼接，存入pyramid\npyramid <- plot_grid(p[[1]],p[[2]],ncol=2,align=\"hv\")\n```\n:::\n\n我们来看看最终的金字塔图的吧。\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_536195044a20c99f3b3ec5bf5e9bba35'}\n\n```{.r .cell-code}\npyramid\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-alt='科研作图，人口金字塔图' width=672}\n:::\n:::\n\n\n## 小结\n\n本篇文章介绍了如何利用R语言制作人口金字塔图，利用本程序的思路，稍微修改，可以批量制作金字塔图。\n                     \n如果你对本篇文章有任何建议，请在页面进行评论吧！\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}