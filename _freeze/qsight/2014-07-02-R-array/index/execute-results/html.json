{
  "hash": "5dc63da15ea8a3721feb799452552cb5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 多维数组与矩阵\ndate: '2014-07-02'\nslug: array\nlink: https://chenq.site/tech/2014-array/\ncategories: [R, R基础知识]\nkeywords: [\"R\",\"R基础知识\",\"array\"]\n---\n\n## 一、生成数组或矩阵 \n\n   数组（array）可以看成是带多个下标的类型相同的集合，常用的是数值型的数组如矩阵（数值型二维数组），也可以有其它类型（如字符型、逻辑性、复数型）。R软件可以很容易地生成和处理数组，特别是矩阵。\n\n   数组有一个特征属性叫做维数向量（dim属性），维数向量是一个元素取正整数的向量，其长度是数组的维数，比如维数向量有两个元素时数组为二维数组（如矩阵）。维数向量的每一个元素指定了该下标的上界，下标的下界总为1.\n\n### （一）将向量定义为数组\n\n   向量可以直接看作为一个一维数组，但要将向量定义为二维以上的数组，需要定义维数向量（dim属性）。比如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nz <- 1:12\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(z) <- c(3,4)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n:::\n\n注意：矩阵的元素是按列存放的。也可以定义为三维数组。如：\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(z) <- c(3,2,2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n```\n\n\n:::\n:::\n\n### （二）用array（）函数构造多维数组\n\n   R软件可以用array（）函数直接构造数组，其构造形式为：\n    \narray(data=NA, dim=length(data) ,dimnames=NULL)\n    \n其中data是一个向量数据，dim是数组各维的长度，缺省时为原向量的长度。dimnames是数组维的名字，缺省时为空。如：\n产生一个4*5的二维数组（矩阵），即：\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-array(1:20,dim=c(4,5))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n```\n\n\n:::\n:::\n\n利用该函数也可以产生三维及以上的数组，如：\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- array(c(1,2,5,7,4,8,9,10), dim=c(2,2,2))\n```\n:::\n\n\n产生一个2*2*2的三维数组。\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    7\n\n, , 2\n\n     [,1] [,2]\n[1,]    4    9\n[2,]    8   10\n```\n\n\n:::\n:::\n\n\n说明：如果数组每个元素相同，则array函数的data部分直接写成数字即可（与下面的matrix（）函数类似）如：\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-array(0,dim=c(4,5))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n[3,]    0    0    0    0    0\n[4,]    0    0    0    0    0\n```\n\n\n:::\n:::\n\n产生一个4*5零矩阵。\n\n### （三）用matrix（）函数构造矩阵\n\n   函数matrix（）是专门用来构造矩阵（二维数组）的函数，其构造形式为\n\n   matrix(data=NA,nrow=1,ncol=1,byrow=FALSE,dimnames=NULL)\n\n   其中data是一个向量数据，nrow是矩阵的行数，ncol是矩阵的列数。当byrow=TRUE时，生成矩阵的数据按行放置，缺省时，相当于byrow=FALSE，按列放置。dimnames是数组维的名字，缺省时为空。\n    比如，构造一个3*5阶的矩阵\n    \n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:15,nrow=3,ncol=5,byrow=TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n```\n\n\n:::\n:::\n\n注意：下面两种方式与上述的格式是等价的。\n\n::: {.cell}\n\n```{.r .cell-code}\n A<-matrix(1:15,nrow=3,byrow=TRUE)\n A<-matrix(1:15,ncol=5,byrow=TRUE)\n```\n:::\n\n\n## 二、数组的下标\n\n   要访问数组的某个元素，只要写出数组名和方括号内的用逗号分开的下标即可，或进行运算。\n\n### （一）数组的下标\n\n::: {.cell}\n\n```{.r .cell-code}\na<-1:24\n dim(a)<-c(2,3,4)\n a[2,1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n要进一步还可以在每一个下标位置写一个下标向量，表示这一维取出所有指定下标的元素，如a[1,2:3,2:3]取出所有第一下标为1，第二下标为2或3，第三下标为2或3的元素，如：\n    \n::: {.cell}\n\n```{.r .cell-code}\na[1,2:3,2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    9   15\n[2,]   11   17\n```\n\n\n:::\n:::\n\n注意：因为第一维只有一个下标，所以退化了，得到一个维数向量为2*2的数组。\n   另外,如果略写某一维的下标，则表示该维全选，例如：\n\n### （二）不规则的数组下标\n\n   在R语言中，甚至可以把数组中的任意位置的元素作为数组访问，其方法就是用一个二维数组作为数组的下标，二维数组的每一行就是一个元素的下标，列数为数组的维数。例如要把上面的性状为3*3的矩阵A的第[1,1] [1,3] [2,1] [2,2]号元素作为一个整体访问，先定义一个包含这些下标作为行的二维数组。\n   \n::: {.cell}\n\n```{.r .cell-code}\nb<-matrix(c(1,1,1,3,2,1,2,2),ncol=2,byrow=TRUE)\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    3\n[3,]    2    1\n[4,]    2    2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\na[b]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 2 1 3 1 2\n```\n\n\n:::\n:::\n\n注意:取出的是一个向量，我们还可以对这几个元素赋值，如：\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\na[b]<-c(3,5,6,7)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    6    5    5\n[2,]    7    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n```\n\n\n:::\n:::\n\n\n## 三、数组的四则运算\n\n### （一）矩阵的乘法\n\n   可以对数组之间进行四则运算(+、-、*、/)，这时进行的是数组对应元素的四则运算，参加运算的数组一般应该是相同性状的（dim属性完全相同）例如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2,byrow=T)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nB<-matrix(1:6,nrow=2)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nC<-matrix(c(1,2,2,3,3,4),nrow=2)\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    3    4\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD<-2*C+A/B\nD\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]     [,2] [,3]\n[1,]    3 4.666667  6.6\n[2,]    6 7.250000  9.0\n```\n\n\n:::\n:::\n\n从这个例子可以看出，数组的加、减运算和数乘运算满足原矩阵运算的性质，但数组的乘、除法运算实际上是数组中对应位置的元素作运算。\n\n## 四、矩阵的运算\n\n### （一）矩阵的乘法\n\n   如果矩阵A和B具有相同的维数，则A*B表示矩阵中对应的元素的乘积A%*%B表示通常意义下的两个矩阵的乘积（当然要求矩阵A的列数等于矩阵B的行数）。如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:9,nrow=3)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB<-matrix(9:1,nrow=3)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    9    6    3\n[2,]    8    5    2\n[3,]    7    4    1\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nC<-A*B;C\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    9   24   21\n[2,]   16   25   16\n[3,]   21   24    9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nD<-A%*%B\nD\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   90   54   18\n[2,]  114   69   24\n[3,]  138   84   30\n```\n\n\n:::\n:::\n\n\n### （二）矩阵的转置运算\n\n对于矩阵A，函数t(A)表示矩阵A的转置，即AT 如：\n\n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nt(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n```\n\n\n:::\n:::\n\n\n### （三）方阵的行列式\n\n   函数det（）是用来求方阵行列式的值，如：\n\n::: {.cell}\n\n```{.r .cell-code}\ndet(matrix(1:4,ncol=2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2\n```\n\n\n:::\n:::\n\n\n### (四)生成对角矩阵和对矩阵取对角运算\n\n   函数diag()依赖于它的变量，当v是一个向量时，diag(v)表示以v的元素为对角元素的对角阵。当M是一个矩阵时，则diag(M)表示的是取M对角线上的元素的向量。如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nv<-c(1,4,5)\ndiag(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    4    0\n[3,]    0    0    5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm<-matrix(1:9,nrow=3)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\n diag(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 9\n```\n\n\n:::\n:::\n\n\n## 五、与矩阵运算有关的函数\n\n### （一）去矩阵的维数\n    \n   函数dim（A）得到矩阵的维数，函数nrow(A)得到矩阵A的行数，函数ncol(A)得到矩阵A的列数。如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n \n::: {.cell}\n\n```{.r .cell-code}\ndim(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nnrow(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n \n::: {.cell}\n\n```{.r .cell-code}\nncol(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n### （二）矩阵的合并\n\n   函数cbind()把其自变量横向拼成一个大矩阵，rbind()把其自变量纵向合拼成一个大矩阵。cbind()的自变量是矩阵或看做列向量的向量时，自变量的高度应该相等。rbind()的自变量是矩阵或看做行向量的向量时，自变量的宽度应该相等。\n    \n   如果参与合并的的自变量比其变量短，则循环补足后合并。如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nx1<-rbind(c(1,2),c(3,4))\nx1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx2<-10+x1\nx3<-cbind(x1,x2)\nx3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2   11   12\n[2,]    3    4   13   14\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx4<-rbind(x1,x2)\nx4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]   11   12\n[4,]   13   14\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(1,x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    2\n[2,]    1    3    4\n```\n\n\n:::\n:::\n\n\n\n### （三）矩阵的拉直（把矩阵转化为向量）\n\n   设A是一个矩阵，则函数as.vector(A)可以将矩阵转化为向量，它是将矩阵A按列拉成向量。如：\n\n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas.vector(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\n### （四）apply函数\n\n   对于想对矩阵的各行或各列进行某种计算，可用apply函数，其一般形式为：\n\n   apply（A，MARGIN，FUN，...）\n\n   其中A为一个矩阵（或数组），MARGIN取1，代表对行进行运算；MARGIN取2，代表队列进行运算，FUN是用来计算的函数。如：\n   \n::: {.cell}\n\n```{.r .cell-code}\nA<-matrix(1:6,nrow=2)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n apply(A,1,sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9 12\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\napply(A,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5 3.5 5.5\n```\n\n\n:::\n:::\n\n说明：求矩阵行列的均值还可分别用函数rowmean()和colmean()。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}